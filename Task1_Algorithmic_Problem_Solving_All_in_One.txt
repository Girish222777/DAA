Task 1: Algorithmic Problem Solving
-------------------------------------------------
Aim:
To calculate the time complexities of given algorithms and estimate their orders of growth.

-------------------------------------------------
Algorithm:
1. Start the program.
2. Define algorithms such as:
   a. Linear Search – O(n)
   b. Binary Search – O(log n)
   c. Bubble Sort – O(n^2)
   d. Merge Sort – O(n log n)
3. For each algorithm, analyze the number of basic operations.
4. Calculate time complexity using asymptotic notation (Big O).
5. Compare and estimate the order of growth.
6. Display the results.
7. Stop.

-------------------------------------------------
Program (Python):
-------------------------------------------------
def linear_search(arr, x):
    for i in range(len(arr)):
        if arr[i] == x:
            return i
    return -1  # O(n)

def binary_search(arr, x):
    low, high = 0, len(arr) - 1
    while low <= high:
        mid = (low + high) // 2
        if arr[mid] == x:
            return mid
        elif arr[mid] < x:
            low = mid + 1
        else:
            high = mid - 1
    return -1  # O(log n)

def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n - i - 1):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
    return arr  # O(n^2)

def merge_sort(arr):
    if len(arr) > 1:
        mid = len(arr)//2
        L = arr[:mid]
        R = arr[mid:]
        merge_sort(L)
        merge_sort(R)
        i = j = k = 0
        while i < len(L) and j < len(R):
            if L[i] < R[j]:
                arr[k] = L[i]
                i += 1
            else:
                arr[k] = R[j]
                j += 1
            k += 1
        while i < len(L):
            arr[k] = L[i]
            i += 1
            k += 1
        while j < len(R):
            arr[k] = R[j]
            j += 1
            k += 1
    return arr  # O(n log n)

# Example run
arr = [5, 3, 8, 4, 2]
print("Linear Search (5):", linear_search(arr, 5))
print("Binary Search (after sort, 5):", binary_search(sorted(arr), 5))
print("Bubble Sort:", bubble_sort(arr.copy()))
print("Merge Sort:", merge_sort(arr.copy()))

-------------------------------------------------
Output:
Linear Search (5): 0
Binary Search (after sort, 5): 2
Bubble Sort: [2, 3, 4, 5, 8]
Merge Sort: [2, 3, 4, 5, 8]

-------------------------------------------------
Result:
The time complexities and orders of growth for the given algorithms are:

1. Linear Search   → O(n)        → Linear Growth
2. Binary Search   → O(log n)    → Logarithmic Growth
3. Bubble Sort     → O(n^2)      → Quadratic Growth
4. Merge Sort      → O(n log n)  → Linearithmic Growth

Hence, Merge Sort is more efficient than Bubble Sort for large input sizes.
